#!/usr/bin/env bash

# Импортируем данные из конфиг-файла, в частности переменную N:
source config.sh

# Скрипт мониторинга только что написанного веб-приложения с логированием в корневой директории скрипта

# Записываю в переменную, где находится файл самого приложения:
webapp_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/webapp.py"
# Объявляю переменную, в которой будет содержаться название логфайла и куда будем его сохранять (для удобства будем создавать его в той же директории где находится сам скрипт monitoring.sh, то есть если даже будем запускать его из другой директории - сохранять будем в том же месте, где и все файлы):
logfile="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/monitoring.log"
# Переменная со статусом работы приложения, значение которой будем записыват в лог:
status_log=0
# Получаю ip, по которому будем проверять доступность приложения (не localhost, чтобы проверять явно извне):
ip=$(python3 "$webapp_path" ip)

# Проверка, если ip не получен:
if [[ -z "$ip" ]]; then
    echo "Error! Run webapp.py or check your network!"
    exit 1
fi

# Формируем из протокола, ip и порта url, по которому будет доступно наше приложение:
app_url="http://$ip:8000"

# Функция, которая будет проверять работает наш сервер или нет (в качестве аргумента передаю наш url) и выведет только число — HTTP-код ответа от сервера (200, если сервер жив):
check()
{
curl -s -o /dev/null -w "%{http_code}" "$1" 
}

# Функция для запуска приложения в фоне:
start_webapp() 
{
# Убиваем старые процессы на всякий случай:
pkill -f "python3.*webapp.py" 2>/dev/null
sleep 1
# Запускаем приложение в фоне:
python3 "$webapp_path" > /dev/null 2>&1 &  
}

# Если при запуске скрипта мониторинга сервер ещё не работает - запускаем его сразу:
if ! curl -s --connect-timeout 2 "$app_url" >/dev/null; then
start_webapp
sleep 3
fi

# Основной цикл мониторинга:
while true; do
http_code=$(check "$app_url")
# Определяю текстовый статус (переменная status_log, которую объявлял ранее) на основе полученного кода:
if [[ "$http_code" == 200 ]]; then
status_log="OK"
elif [[ "$http_code" == "000" ]]; then
status_log="FAILED (SERVER IS DOWN)"
# Перезапускаем сервер:
start_webapp
sleep 5
else
status_log="FAILED (HTTP ERROR $http_code)"
fi
# Записываем отформатированные текущие дату и время в переменную:
timedate=$(date +"%Y-%m-%d %H:%M:%S")
# Дописываем новую строку в конец файла:
echo "$timedate STATUS: $status_log" >> "$logfile"
# Устанавливаю задержку в N секунд, чтобы осуществлять проверку с данной периодичностью:
sleep "$N"
done